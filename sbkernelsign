#!/usr/bin/env python3

# Copyright (c) 2018 Anton Semjonov
# Licensed under the MIT License

# Script to automate the bundling and signing of EFISTUB compatible
# kernels into a single singed binary for usage on systems with
# enabled SecureBoot. The DatabaseKey.key must be enrolled in your
# firmware for this to work.

# TODO: handle kernel deletion by deleting signed binary?
# TODO: add 'sign' command to sign single extra binaries

import sys
import os
from configparser import ConfigParser, ExtendedInterpolation, DuplicateSectionError
from re import compile
from glob import iglob
import subprocess
import logging
from efistub import efistub_combine, parse_kernelversion

# get a named logger
logger = lambda s: logging.getLogger(s)

# return a config section as dict for **kwargs
sectdict = lambda s: dict(s.items())

# configuration element
class Configuration(object):

    DEFAULT_CONFIGURATION = "/etc/sbkernelsign.cfg"
    DEFAULT_STUB = "/usr/lib/systemd/boot/efi/linuxx64.efi.stub"
    DEFAULT_KEY = "/etc/efikeys/DatabaseKey.key"
    DEFAULT_CERT = "/etc/efikeys/DatabaseKey.crt"
    DEFAULT_BOOT = "/boot"
    DEFAULT_REXP = "(?:.*/|)vmlinuz-([^/]+)$"

    # initialize config parser with ${var} interpolation and loose section headers
    def __init__(self, file):

        self.cfg = ConfigParser(interpolation=ExtendedInterpolation())
        self.cfg.SECTCRE = compile(r"\[ *(?P<header>[^]]+?) *\]")
        self.cfg.read_file(file)

        self.boot = self.cfg.get(self.GLOBAL, "boot", fallback=self.DEFAULT_BOOT)
        self.rexp = compile(self.cfg.get(self.GLOBAL, "rexp", fallback=self.DEFAULT_REXP))

        self.stub = self.cfg.get(self.GLOBAL, "stub", fallback=self.DEFAULT_STUB)

        self.key = self.cfg.get(self.GLOBAL, "key", fallback=self.DEFAULT_KEY)
        self.cert = self.cfg.get(self.GLOBAL, "cert", fallback=self.DEFAULT_CERT)

    # return globals as dict
    GLOBAL = "global"

    def globals(self):
        return {"stub": self.stub, "key": self.key, "cert": self.cert}

    # add sections by globbing for kernels on filesystem
    def addglob(self):
        logger("*").debug(f"searching for kernels in {self.boot} with {self.rexp}")
        for f in os.scandir(self.boot):
            if f.is_file():
                m = self.rexp.findall(f.path)
                if m: self.addsection(m[0][1])

    # ensures that a named section is present
    def addsection(self, name):
        try:
            self.cfg.add_section(name)
            logger("*").debug("kernel found: %s" % name)
        except DuplicateSectionError:
            pass
        return self.cfg[name]

    def kernels(self, targets=None):

        kernels = []
        sections = (s for s in (self.cfg.sections() if targets is None else targets) if s != self.GLOBAL)

        for name in sections:
            section = self.addsection(name)
            log = logger(name)

            if "ignore" in section and section.getboolean("ignore"):
                log.debug("ignored")
                continue

            if not "name" in section:
                section["name"] = name.strip()

            try:
                k = Kernel(name, **self.globals(), **sectdict(section))
                kernels.append(k)
            except TypeError as e:
                log.error(f"missing attribute: {e}")
                continue

        if len(kernels) == 0:
            logger("*").warning("empty kernel list")
            exit(0)

        return kernels

# things that call external binaries or scripts
class Run(object):

    # combine efistub, kernel and initramfs into a single binary
    @staticmethod
    def objcopy(stub, kernel, initramfs, cmdline, output):
        stub = open(stub, 'rb')
        kernel = open(kernel, 'rb')
        initramfs = [open(i, 'rb') for i in initramfs]
        output = open(output, 'wb')
        # TODO: return osrel data from efistub_combine
        # TODO: add name to osrel info
        v = parse_kernelversion(kernel)
        print(f"kernel version: {v}")
        return efistub_combine(stub, kernel, initramfs, cmdline, output)

    # create a signature on the combined binary
    @staticmethod
    def sbsign(key, cert, binary):
        cmd = ["sbsign", "--key", key, "--cert", cert, "--output", binary, binary]
        return subprocess.run(cmd, check=True)


# a single kernel signing configuration with its processing steps
class Kernel(object):
    def __init__(self, logname, name, stub, kernel, initramfs, cmdline, key, cert, output, **rest):
        self.name = name
        self.log = logger(logname)
        self.stub = stub
        self.kernel = kernel
        self.initramfs = initramfs if type(initramfs) == list else initramfs.strip().splitlines()
        self.cmdline = cmdline
        self.key = key
        self.cert = cert
        self.output = output

        # skip removed kernels
        if not os.path.isfile(self.kernel):
            raise TypeError("kernel removed")
        # all other files should exist
        for f in [self.stub] + self.initramfs + [self.key, self.cert]:
            if not os.path.isfile(f):
                raise FileNotFoundError(self.name + ": " + f)

    def print(self):
        # print info about this kernel
        self.log.info(f"combining and signing kernel")
        for k in ("stub", "kernel", "initramfs", "cmdline", "output"):
            self.log.debug(f"{k}: {getattr(self, k)}")
        return self

    def backup(self, suffix):
        import shutil
        import os

        if os.path.isfile(self.output):
            backup = self.output + suffix
            shutil.copy2(self.output, backup)
            self.log.debug("backed up old kernel to " + backup)
        return self

    def sign(self):
        Run.objcopy(self.stub, self.kernel, self.initramfs, self.cmdline, self.output)
        Run.sbsign(self.key, self.cert, self.output)
        return self


class Commandline(object):
    def __init__(self):
        from argparse import ArgumentParser, FileType

        parser = ArgumentParser(description="Bundle and sign kernels for secureboot systems.")
        commands = parser.add_subparsers(required=True, metavar="command", help="(for more information use: <command> --help)")
        defaults = {"config": Configuration.DEFAULT_CONFIGURATION, "logging": "INFO", "no_glob": False}

        # --- automatic mode ---
        auto = commands.add_parser("auto", help="automatic, from configuration file")
        auto.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        auto.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        auto.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        auto.set_defaults(**defaults, func=self.auto)

        # --- hook mode ---
        hook = commands.add_parser("hook", help="hook mode for pacman")
        hook.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        hook.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        hook.set_defaults(**defaults, func=self.hook)

        # --- manual mode ---
        manual = commands.add_parser("manual", help="manual, all args provided")
        manual.add_argument("-k", dest="kernel", help="kernel binary", required=True)
        manual.add_argument(
            "-i", dest="initramfs", help="initramfs list", nargs="+", metavar="IMG", required=True
        )
        manual.add_argument("-c", dest="cmdline", help="kernel cmdline", required=True)
        manual.add_argument("-o", dest="output", help="signed kernel output", required=True)
        manual.add_argument("-K", dest="key", help="signing key")
        manual.add_argument("-C", dest="cert", help="signing certificate")
        manual.add_argument("-e", dest="stub", help="systemd-boot efistub")
        manual.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        manual.set_defaults(
            **defaults,
            func=self.manual,
            **{
                "key": Configuration.DEFAULT_KEY,
                "cert": Configuration.DEFAULT_CERT,
                "stub": Configuration.DEFAULT_STUB,
                "name": "manual",
            },
        )

        args = parser.parse_args()
        loglevel = getattr(logging, args.logging or "INFO")
        logging.basicConfig(
            format="[%(name)s] %(message)s", level=loglevel
        )
        args.func(args)

    # automatic mode
    def auto(self, args):

        # open configuration, add globbing
        conf = Configuration(args.config)
        if not args.no_glob:
            conf.addglob()

        # combine and sign kernels
        self.signall(conf.kernels())

    # hook mode for pacman
    def hook(self, args):

        # open configuration
        conf = Configuration(args.config)

        # parse targets on stdin
        targets, force = [], False
        for line in (line.strip() for _, line in enumerate(sys.stdin)):
            match = conf.rexp.match(line)
            if match is None:
                force = True
                continue
            # add matches to list of targets
            name = match.group(1)
            conf.addsection(name)
            targets.append(name)

        # if any target did not match kernel regexp, force auto rebuild
        if force:
            logger("*").info("forced complete resign")
            conf.addglob()
            targets = None

        # combine and sign kernels
        self.signall(conf.kernels(targets))

    # fully manual mode
    def manual(self, args):

        kernel = Kernel(**(args.__dict__))
        self.signall([kernel])

    # helper to perform combine and sign
    def signall(self, kernels, backup=".bak"):
        for k in kernels:
            k.print().backup(backup).sign()


# ------- let's go -------
if __name__ == "__main__":
    Commandline()

