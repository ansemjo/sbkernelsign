#!/usr/bin/env python3

# Copyright (c) 2018 Anton Semjonov
# Licensed under the MIT License

# Script to automate the bundling and signing of EFISTUB compatible
# kernels into a single singed binary for usage on systems with
# enabled SecureBoot. The DatabaseKey.key must be enrolled in your
# firmware for this to work.

# minimum Python 3.8 required: f"" strings and := operators

import sys, os, re, subprocess, logging, string, shutil, configparser as cfp
from efistub import efistub_combine, parse_kernelversion

# get a named logger
logger = lambda s: logging.getLogger(s)

# configuration element from file and searching for kernels
class Configuration(object):

    # default configuration values
    DEFAULTS = {
        "boot" : "/boot",
        "rexp" : "(?:.*/|)vmlinuz-([^/]+)$$",
        "stub" : "/usr/lib/systemd/boot/efi/linuxx64.efi.stub",
        "key"  : "/etc/efikeys/DatabaseKey.key",
        "cert" : "/etc/efikeys/DatabaseKey.crt",
    }

    # extended interpolation where ${section} is always the section name
    class ExtendedSectionInterpolation(cfp.ExtendedInterpolation):
        def before_get(self, parser, section, option, value, defaults):
            parser.set(section, "section", section)
            return super().before_get(parser, section, option, value, defaults)
    
    # initialize config parser with extended ${variable} interpolation
    def __init__(self, file):
        self.cfg = cfp.ConfigParser(interpolation=self.ExtendedSectionInterpolation())
        self.cfg.read_file(file)

        # write missing default values to DEFAULT section for interpolation
        for key in filter(lambda k: k not in self.cfg.defaults().keys(), self.DEFAULTS.keys()):
            self.cfg.set(self.cfg.default_section, key, self.DEFAULTS[key])

        # assign boot and rexp on self because they're needed
        self.boot = self.cfg.get(self.cfg.default_section, "boot")
        self.rexp = self.cfg.get(self.cfg.default_section, "rexp")

    # add sections by globbing for kernels on filesystem
    def find_kernels(self):
        logger("*").debug(f"find kernels in {self.boot} with /{self.rexp}/")
        kre = re.compile(self.rexp)
        for file in filter(lambda f: f.is_file(), os.scandir(self.boot)):
            if (match := kre.match(file.path)):
                name = match.group(1)
                logger("*").debug(f"kernel found: {name}")
                self.add_section(name)

    # ensure that a named kernel config section is present
    def add_section(self, name):
        try: self.cfg.add_section(name)
        except cfp.DuplicateSectionError: pass
        return self.cfg[name]

    # return a generator of Kernel objects for processing
    def kernels(self, specific=None):
        sections = (self.cfg.sections() if specific is None else specific)
        if not len(sections):
            logger("*").debug("empty kernels list")
            sys.exit(1)

        # generate the configurations
        for name in sections:
            section = self.add_section(name)

            # skip if explicitly ignored
            if section.getboolean("ignore", False):
                logger(name).debug("ignored")
                continue

            # transform initrd to list
            items = dict(section.items())
            items["initrd"] = items["initrd"].strip().splitlines()

            # yield a kernel configuration from interpolated values
            yield Kernel(name, **items)


# a single kernel signing configuration and its processing steps
class Kernel(object):

    # many functions herein return self for dot-chaining
    def __init__(self, name, stub, kernel, initrd, cmdline, key, cert, output, **rest):
        self.name = name
        self.log = logger(name)
        self.stub = stub
        self.kernel = kernel
        self.initrd = initrd
        self.cmdline = cmdline
        self.key = key
        self.cert = cert
        self.output = output

    # check if all expected files are present and readable
    # TODO: special case for hooks with removed files
    def checkfiles(self):
        for file in [self.kernel, self.stub, *self.initrd, self.key, self.cert]:
            if not os.path.isfile(file):
                raise FileNotFoundError(f"not a file: {file}")
            if not os.access(file, os.R_OK):
                raise PermissionError(f"cannot read file: {file}")
        return self

    # print info about this config
    def info(self):
        for k in ("stub", "kernel", "initrd", "cmdline", "output"):
            self.log.debug(f"{k:7s}: {getattr(self, k)}")
        return self

    # backup existing kernels with a suffix in place
    def backup(self, suffix="~"):
        if os.path.isfile(self.output):
            backup = self.output + suffix
            shutil.copy2(self.output, backup)
            self.log.debug(f"backed up old kernel to {backup}")
        return self

    # combine efistub, kernel and initrd into a single binary
    def objcopy(self, hook=False):
        stub = open(self.stub, 'rb')
        kernel = open(self.kernel, 'rb')
        initrd = [open(i, 'rb') for i in self.initrd]
        output = open(self.output, 'wb')
        # TODO: add verbose flag to print version / osrel
        # TODO: add name to osrel info for bootloader selections
        efistub_combine(stub, kernel, initrd, self.cmdline, output)
        return self

    # create a signature on the combined binary
    def sbsign(self):
        cmd = ["sbsign", "--key", self.key, "--cert", self.cert, "--output", self.output, self.output]
        subprocess.run(cmd, check=True)
        return self

    # run all of the above
    def combine(self):
        return self.checkfiles().info().backup().objcopy().sbsign()


# parse the commandline and run the appropriate function
# TODO: add 'sign' command to sign single extra binaries
class Commandline(object):
    def __init__(self):
        from argparse import ArgumentParser, FileType

        parser = ArgumentParser(description="Bundle and sign kernels for secureboot systems.")
        commands = parser.add_subparsers(required=True, metavar="command", help="(for more information use: <command> --help)")
        defaults = {
            "config": "/etc/sbkernelsign.cfg",
            "logging": "INFO",
            "no_glob": False
        }

        # --- automatic mode ---
        auto = commands.add_parser("auto", help="automatic, from configuration file")
        auto.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        auto.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        auto.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        auto.set_defaults(**defaults, func=self.auto)

        # --- hook mode ---
        hook = commands.add_parser("hook", help="hook mode for pacman")
        hook.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        hook.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        hook.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        hook.set_defaults(**defaults, func=self.hook)

        # --- manual mode ---
        manual = commands.add_parser("manual", help="manual, all args provided")
        manual.add_argument("-k", dest="kernel", help="kernel binary", required=True)
        manual.add_argument("-i", dest="initrd", help="initrd list", nargs="+", metavar="IMG", required=True)
        manual.add_argument("-c", dest="cmdline", help="kernel cmdline", required=True)
        manual.add_argument("-o", dest="output", help="signed kernel output", required=True)
        manual.add_argument("-K", dest="key", help="signing key", required=True)
        manual.add_argument("-C", dest="cert", help="signing certificate", required=True)
        manual.add_argument("-e", dest="stub", help="systemd-boot efistub", required=True)
        manual.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        manual.set_defaults(**defaults, func=self.manual)

        args = parser.parse_args()
        loglevel = getattr(logging, args.logging or "INFO")
        logging.basicConfig(format="[%(name)s] %(message)s", level=loglevel)
        args.func(args)

    # automatic mode: search for kernels and combine all
    def auto(self, args):
        conf = Configuration(args.config)
        if not args.no_glob: conf.find_kernels()
        self.signall(conf.kernels())

    # hook mode for package managers: parse changed targets from stdin
    def hook(self, args):
        conf = Configuration(args.config)
        targets, full = [], False
        kre = re.compile(conf.rexp)
        
        # check lines
        for line in (line.strip() for _, line in enumerate(sys.stdin)):
            if (match := kre.match(line)):
                # add all kernel rexp matches to a list
                name = match.group(1)
                targets.append(name)
            else:
                # if any is not a kernel, force full resign
                full = True
                continue

        # full auto rebuild if any target did not match kernel regexp
        if full:
            logger("*").info("forced complete resign")
            if not args.no_glob: conf.find_kernels()
            targets = None

        # combine and sign kernels
        self.signall(conf.kernels(targets))

    # fully manual mode, all arguments specified
    def manual(self, args):
        kernel = Kernel("manual", **(args.__dict__))
        self.signall([kernel])

    # helper to perform combine and sign
    def signall(self, kernels):
        for k in kernels:
            try:
                k.combine()
            except Exception as e:
                k.log.error(e)
                sys.exit(1)


# ------- let's go -------
if __name__ == "__main__":
    Commandline()

