#!/usr/bin/env python3

# Copyright (c) 2018 Anton Semjonov
# Licensed under the MIT License

# Script to automate the bundling and signing of EFISTUB compatible
# kernels into a single singed binary for usage on systems with
# enabled SecureBoot. The DatabaseKey.key must be enrolled in your
# firmware for this to work.

# minimum Python 3.8 required: f"" strings and := operators

import sys, os, re, subprocess, logging, string, shlex, datetime as dt
import tempfile, struct, shutil, configparser as cfp

# get a named logger
logger = lambda s: logging.getLogger(s)

# return a file descriptor number
fd = lambda f: f.fileno()

# get an iso format timestamp
timestamp = lambda: dt.datetime.now(dt.timezone.utc).strftime("%FT%TZ")


# configuration element from file and searching for kernels
class Configuration(object):

    # default configuration values
    DEFAULTS = {
        "boot"    : "/boot",
        "esp"     : "${boot}/efi",
        "output"  : "${esp}/EFI/Linux/${section}.efi",
        "rexp"    : "(?:.*/|)vmlinuz-([^/]+)$$",
        "stub"    : "/usr/lib/systemd/boot/efi/linuxx64.efi.stub",
        "pki"     : "/etc/efikeys",
        "key"     : "${pki}/DatabaseKey.key",
        "cert"    : "${pki}/DatabaseKey.crt",
        "kernel"  : "${boot}/vmlinuz-${section}",
        "initrd"  : "${boot}/initramfs-${section}.img",
        "cmdline" : "quiet",
    }

    # extended interpolation where ${section} is always the section name
    class ExtendedSectionInterpolation(cfp.ExtendedInterpolation):
        def before_get(self, parser, section, option, value, defaults):
            parser.set(section, "section", section)
            return super().before_get(parser, section, option, value, defaults)
    
    # initialize config parser with extended ${variable} interpolation
    def __init__(self, file):
        self.cfg = cfp.ConfigParser(interpolation=self.ExtendedSectionInterpolation())
        self.cfg.read_file(file)

        # write missing default values to DEFAULT section for interpolation
        for key in filter(lambda k: k not in self.cfg.defaults().keys(), self.DEFAULTS.keys()):
            self.cfg.set(self.cfg.default_section, key, self.DEFAULTS[key])

        # assign boot and rexp on self because they're needed
        self.boot = self.cfg.get(self.cfg.default_section, "boot")
        self.rexp = self.cfg.get(self.cfg.default_section, "rexp")

    # add sections by globbing for kernels on filesystem
    def find_kernels(self):
        logger("*").debug(f"find kernels in {self.boot} with /{self.rexp}/")
        kre = re.compile(self.rexp)
        for file in filter(lambda f: f.is_file(), os.scandir(self.boot)):
            if (match := kre.match(file.path)):
                name = match.group(1)
                logger("*").debug(f"kernel found: {name}")
                self.add_section(name)

    # ensure that a named kernel config section is present
    def add_section(self, name):
        try: self.cfg.add_section(name)
        except cfp.DuplicateSectionError: pass
        return self.cfg[name]

    # return a generator of Kernel objects for processing
    def kernels(self, specific=None):
        sections = (self.cfg.sections() if specific is None else specific)
        if not len(sections):
            logger("*").debug("empty kernels list")
            sys.exit(1)

        # generate the configurations
        for name in sections:
            section = self.add_section(name)

            # skip if explicitly ignored
            if section.getboolean("ignore", False):
                logger(name).debug("ignored")
                continue

            # transform initrd to list
            items = dict(section.items())
            items["initrd"] = items["initrd"].strip().splitlines()

            # yield a kernel configuration from interpolated values
            yield Kernel(name, **items)


# a single kernel signing configuration and its processing steps
class Kernel(object):

    # many functions herein return self for dot-chaining
    def __init__(self, name, stub, kernel, initrd, cmdline, key, cert, output, **rest):
        self.name = name
        self.log = logger(name)
        self.stub = stub
        self.kernel = kernel
        self.initrd = initrd
        self.cmdline = cmdline
        self.key = key
        self.cert = cert
        self.output = output

    # check if all expected files are present and readable
    # TODO: special case for hooks with removed files
    def checkfiles(self):
        for file in [self.kernel, self.stub, *self.initrd, self.key, self.cert]:
            if not os.path.isfile(file):
                raise FileNotFoundError(f"not a file: {file}")
            if not os.access(file, os.R_OK):
                raise PermissionError(f"cannot read file: {file}")
        return self

    # print info about this config
    def info(self):
        self.log.info("signing combined kernel")
        for k in ("stub", "kernel", "initrd", "cmdline", "output"):
            self.log.debug(f"{k:7s}: {getattr(self, k)}")
        return self

    # backup existing kernels with a suffix in place
    def backup(self, suffix="~"):
        if os.path.isfile(self.output):
            backup = self.output + suffix
            shutil.copy2(self.output, backup)
            self.log.debug(f"backed up old kernel to {backup}")
        return self

    # combine efistub, kernel and initrd into a single binary
    def combisign(self, hook=False):
        stub = open(self.stub, 'rb')
        kernel = open(self.kernel, 'rb')
        initrd = [open(i, 'rb') for i in self.initrd]
        output = open(self.output, 'w+b')
        efistubcombine(stub, kernel, initrd, self.cmdline, output, self.name)
        sbsign(output, self.key, self.cert)
        [f.close() for f in [stub, kernel, *initrd, output]]
        return self

    # run all of the above
    def doit(self):
        return self.checkfiles().info().backup().combisign()


# concatenate multiple open files in a spooled tempfile
def concat(*files):
    tmp = tempfile.SpooledTemporaryFile()
    for file in files:
        shutil.copyfileobj(file, tmp)
        file.close()
    tmp.seek(0)
    return tmp

# write bytes to a spooled tempfile
def spool(data):
    tmp = tempfile.SpooledTemporaryFile(mode="wb+")
    tmp.write(data)
    tmp.seek(0)
    return tmp

# parse os-release and return either PRETTY_NAME, NAME or 'Linux'
def get_osname(osrel = "/etc/os-release"):
    with open(osrel, "rt") as file:
        osdict = {}
        for line in file:
            k, v = line.split("=", 1)
            osdict[k] = shlex.split(v)[0]
        return osdict.get("PRETTY_NAME", osdict.get("NAME", "Linux"))

# generate a minimal os-release dynamically for embedding with efistub
# https://github.com/systemd/systemd/blob/72830b187f5aa06b3e89ca121bbc35451764f1bc/docs/BOOT_LOADER_SPECIFICATION.md#type-2-efi-unified-kernel-images
def osrelease(os, name, version):
    tmp = tempfile.SpooledTemporaryFile(mode='wt+')
    print(f"PRETTY_NAME={shlex.quote(os)}", file=tmp)
    print(f"ID={shlex.quote(name)}", file=tmp)
    print(f"VERSION_ID={shlex.quote(version)}", file=tmp)
    tmp.seek(0)
    return tmp

# parse version from an open kernel file
# https://github.com/file/file/blob/31a82018c2ed153b84ea5e115fa855de24eb46d1/magic/Magdir/linux#L109
def parse_kernelversion(k):
    # save position to restore later
    s = k.tell()
    # check 'magic' bytes
    if not k.seek(514) or not k.read(4) == b"HdrS":
        raise ValueError("%s is not a Linux kernel" % k.name)
    # seek to version string via offset
    k.seek(526)
    offset = struct.unpack("<h", k.read(2))[0]
    k.seek(offset + 512)
    # read and split kernel version, restore seek
    v = k.read(256).split(b" ", 1)[0].decode()
    k.seek(s)
    return v

# combine efistub, kernel and initramfs in a single efi executable with objcopy
def objcopy(efistub, kernel, initrd, cmdline, osrel, output):
    # maybe concatenate initramfs in memory
    if isinstance(initrd, list):
        initrd = concat(*initrd)
    # combine with objcopy subprocess
    return subprocess.run([
        "objcopy",
        "--add-section", f".osrel=/dev/fd/{fd(osrel)}",
        "--change-section-vma", ".osrel=0x0020000",
        "--add-section", f".cmdline=/dev/fd/{fd(cmdline)}",
        "--change-section-vma", ".cmdline=0x0030000",
        "--add-section", f".linux=/dev/fd/{fd(kernel)}",
        "--change-section-vma", ".linux=0x2000000",
        "--add-section", f".initrd=/dev/fd/{fd(initrd)}",
        "--change-section-vma", ".initrd=0x3000000",
        f"/dev/fd/{fd(efistub)}",
        f"/dev/fd/{fd(output)}"],
        pass_fds=[fd(f) for f in [efistub, kernel, initrd, cmdline, osrel, output]],
        check=True,
    )

# wrapper that generates osreal dynamically and combines kernel
def efistubcombine(efistub, kernel, initrd, cmdline, output, name=None):
    # spool cmdline in file
    cmdline = spool(cmdline.encode("utf-8"))
    # generate a spooled osrel file
    osname = get_osname()
    name = os.path.basename(kernel.name) if name is None else name
    # TODO: parse_kernelversion either succeeds or raises ..
    version = parse_kernelversion(kernel) or timestamp()
    # TODO: add optional logging of osrel info
    osrel = osrelease(osname, name, version)
    # combine into output file
    return objcopy(efistub, kernel, initrd, cmdline, osrel, output)

# create a signature on a binary
def sbsign(binary, key, cert):
    return subprocess.run([
        "sbsign", "--key", key, "--cert", cert,
        "--output", f"/dev/fd/{fd(binary)}", f"/dev/fd/{fd(binary)}"],
        pass_fds=[fd(binary)],
        check=True,
    )


# ---------- commandlines ---------- #

# standalone efistub-combine script without signing
class EFIStubCmd(object):
    def __init__(self):
        from argparse import ArgumentParser, FileType
        p = ArgumentParser()
        p.add_argument("-e", dest="efistub", help="efi loader stub", type=FileType('rb'), default=Configuration.DEFAULTS["stub"])
        p.add_argument("-k", dest="kernel", help="linux kernel", type=FileType('rb'), required=True)
        p.add_argument("-i", dest="initrd", help="initramfs image", type=FileType('rb'), action='append', required=True)
        p.add_argument("-c", dest="cmdline", help="kernel commandline", default="")
        p.add_argument("-n", dest="name", help="embed name in osrel", default=None)
        p.add_argument("-o", dest="output", help="output file", type=FileType('wb'), required=True)
        args = p.parse_args()
        proc = efistubcombine(**vars(args))
        exit(proc.returncode)


# parse the commandline and run the appropriate function
# TODO: add 'sign' command to sign single extra binaries
class SBKernelSignCmd(object):
    def __init__(self):
        from argparse import ArgumentParser, FileType

        parser = ArgumentParser(description="Bundle and sign kernels for secureboot systems.")
        commands = parser.add_subparsers(required=True, metavar="command", help="(for more information use: <command> --help)")
        defaults = {
            "config": "/etc/sbkernelsign.cfg",
            "logging": "INFO",
            "no_glob": False
        }

        # --- automatic mode ---
        auto = commands.add_parser("auto", help="automatic, from configuration file")
        auto.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        auto.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        auto.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        auto.set_defaults(**defaults, func=self.auto)

        # --- hook mode ---
        hook = commands.add_parser("hook", help="hook mode for pacman")
        hook.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        hook.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        hook.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        hook.set_defaults(**defaults, func=self.hook)

        # --- manual mode ---
        manual = commands.add_parser("manual", help="manual, all args provided")
        manual.add_argument("-k", dest="kernel", help="kernel binary", required=True)
        manual.add_argument("-i", dest="initrd", help="initrd list", nargs="+", metavar="IMG", required=True)
        manual.add_argument("-c", dest="cmdline", help="kernel cmdline", required=True)
        manual.add_argument("-o", dest="output", help="signed kernel output", required=True)
        manual.add_argument("-K", dest="key", help="signing key", required=True)
        manual.add_argument("-C", dest="cert", help="signing certificate", required=True)
        manual.add_argument("-e", dest="stub", help="systemd-boot efistub", required=True)
        manual.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        manual.set_defaults(**defaults, func=self.manual)

        args = parser.parse_args()
        loglevel = getattr(logging, args.logging or "INFO")
        logging.basicConfig(format="[%(name)s] %(message)s", level=loglevel)
        args.func(args)

    # automatic mode: search for kernels and combine all
    def auto(self, args):
        conf = Configuration(args.config)
        if not args.no_glob: conf.find_kernels()
        self.signall(conf.kernels())

    # hook mode for package managers: parse changed targets from stdin
    def hook(self, args):
        conf = Configuration(args.config)
        targets, full = [], False
        kre = re.compile(conf.rexp)
        
        # check lines
        for line in (line.strip() for _, line in enumerate(sys.stdin)):
            if (match := kre.match(line)):
                # add all kernel rexp matches to a list
                name = match.group(1)
                targets.append(name)
            else:
                # if any is not a kernel, force full resign
                full = True
                continue

        # full auto rebuild if any target did not match kernel regexp
        if full:
            logger("*").info("forced complete resign")
            if not args.no_glob: conf.find_kernels()
            targets = None

        # combine and sign kernels
        self.signall(conf.kernels(targets))

    # fully manual mode, all arguments specified
    def manual(self, args):
        kernel = Kernel("manual", **(args.__dict__))
        self.signall([kernel])

    # helper to perform combine and sign
    def signall(self, kernels):
        for k in kernels:
            try:
                k.doit()
            except Exception as e:
                k.log.error(e)
                sys.exit(1)


# ---------- interactive ---------- #

if __name__ == "__main__":
    # get the filename we're called by
    called = os.path.basename(sys.argv[0])
    # and run appropriate app
    if called.startswith("efistub"): EFIStubCmd()
    else: SBKernelSignCmd()
