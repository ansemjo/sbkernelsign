#!/usr/bin/env python3

# Copyright (c) 2018 Anton Semjonov
# Licensed under the MIT License

# Script to automate the bundling and signing of EFISTUB compatible
# kernels into a single singed binary for usage on systems with
# enabled SecureBoot. The DatabaseKey.key must be enrolled in your
# firmware for this to work.

# minimum Python 3.8 required: f"" strings and := operators

# TODO: add 'sign' command to sign single extra binaries
# TODO: return osrel data from efistub_combine for logging
# TODO: add name to osrel info for bootloader selections

import sys, os, re, subprocess, logging, string, configparser as cfp
from efistub import efistub_combine, parse_kernelversion

# get a named logger
logger = lambda s: logging.getLogger(s)

# configuration element from file and searching for kernels
class Configuration(object):

    DEFAULT_CONFIGURATION = "/etc/sbkernelsign.cfg"

    # default configuration values
    DEFAULTS = {
        "boot" : "/boot",
        "rexp" : "(?:.*/|)vmlinuz-([^/]+)$$",
        "stub" : "/usr/lib/systemd/boot/efi/linuxx64.efi.stub",
        "key"  : "/etc/efikeys/DatabaseKey.key",
        "cert" : "/etc/efikeys/DatabaseKey.crt",
    }

    # extended interpolation where ${section} is always the section name
    class ExtendedSectionInterpolation(cfp.ExtendedInterpolation):
        def before_get(self, parser, section, option, value, defaults):
            parser.set(section, "section", section)
            return super().before_get(parser, section, option, value, defaults)
    
    # initialize config parser with extended ${variable} interpolation
    def __init__(self, file):
        self.cfg = cfp.ConfigParser(interpolation=self.ExtendedSectionInterpolation())
        self.cfg.read_file(file)

        # write missing default values to DEFAULT section for interpolation
        for key in filter(lambda k: k not in self.cfg.defaults().keys(), self.DEFAULTS.keys()):
            self.cfg.set(self.cfg.default_section, key, self.DEFAULTS[key])

    # add sections by globbing for kernels on filesystem
    def find_kernels(self):
        boot, rexp = (self.cfg.get(self.cfg.default_section, k) for k in ["boot", "rexp"])
        logger("*").debug(f"find kernels in {boot} with /{rexp}/")
        kre = re.compile(rexp)
        for file in filter(lambda f: f.is_file(), os.scandir(boot)):
            if (match := kre.match(file.path)):
                name = match.group(1)
                logger("*").debug(f"kernel found: {name}")
                self.add_section(name)

    # ensure that a named kernel config section is present
    def add_section(self, name):
        try: self.cfg.add_section(name)
        except cfp.DuplicateSectionError: pass
        return self.cfg[name]

    # return a generator of Kernel objects for processing
    def kernels(self, specific=None):
        sections = (self.cfg.sections() if specific is None else specific)
        if not len(sections):
            logger("*").debug("empty kernels list")
            sys.exit(1)

        # generate the configurations
        for name in sections:
            section = self.add_section(name)

            # skip if explicitly ignored
            if section.getboolean("ignore", False):
                logger(name).debug("ignored")
                continue

            try:
                yield Kernel(name, **dict(section.items()))
            except TypeError as e:
                logger(name).error(f"missing attribute: {e}")
                continue


# a single kernel signing configuration with its processing steps
class Kernel(object):
    def __init__(self, name, stub, kernel, initrd, cmdline, key, cert, output, **rest):
        self.name = name
        self.log = logger(name)
        self.stub = stub
        self.kernel = kernel
        self.initrd = initrd if type(initrd) == list else initrd.strip().splitlines()
        self.cmdline = cmdline
        self.key = key
        self.cert = cert
        self.output = output

        # skip removed kernels
        if not os.path.isfile(self.kernel):
            raise TypeError("kernel removed")
        # all other files should exist
        for f in [self.stub] + self.initrd + [self.key, self.cert]:
            if not os.path.isfile(f):
                raise FileNotFoundError(self.name + ": " + f)

    def print(self):
        # print info about this kernel
        self.log.info(f"combining and signing kernel")
        for k in ("stub", "kernel", "initrd", "cmdline", "output"):
            self.log.debug(f"{k}: {getattr(self, k)}")
        return self

    def backup(self, suffix):
        import shutil
        import os

        if os.path.isfile(self.output):
            backup = self.output + suffix
            shutil.copy2(self.output, backup)
            self.log.debug("backed up old kernel to " + backup)
        return self

    def sign(self):
        #Kernel.objcopy(self.stub, self.kernel, self.initrd, self.cmdline, self.output)
        #Kernel.sbsign(self.key, self.cert, self.output)
        return self

    # combine efistub, kernel and initrd into a single binary
    @staticmethod
    def objcopy(stub, kernel, initrd, cmdline, output):
        stub = open(stub, 'rb')
        kernel = open(kernel, 'rb')
        initrd = [open(i, 'rb') for i in initrd]
        output = open(output, 'wb')
        v = parse_kernelversion(kernel)
        print(f"kernel version: {v}")
        return efistub_combine(stub, kernel, initrd, cmdline, output)

    # create a signature on the combined binary
    @staticmethod
    def sbsign(key, cert, binary):
        cmd = ["sbsign", "--key", key, "--cert", cert, "--output", binary, binary]
        return subprocess.run(cmd, check=True)


class Commandline(object):
    def __init__(self):
        from argparse import ArgumentParser, FileType

        parser = ArgumentParser(description="Bundle and sign kernels for secureboot systems.")
        commands = parser.add_subparsers(required=True, metavar="command", help="(for more information use: <command> --help)")
        defaults = {"config": Configuration.DEFAULT_CONFIGURATION, "logging": "INFO", "no_glob": False}

        # --- automatic mode ---
        auto = commands.add_parser("auto", help="automatic, from configuration file")
        auto.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        auto.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        auto.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        auto.set_defaults(**defaults, func=self.auto)

        # --- hook mode ---
        hook = commands.add_parser("hook", help="hook mode for pacman")
        hook.add_argument("-c", dest="config", help="configuration file", type=FileType("r"))
        hook.add_argument("--no-glob", help="do not automatically add kernels", action="store_true")
        hook.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        hook.set_defaults(**defaults, func=self.hook)

        # --- manual mode ---
        manual = commands.add_parser("manual", help="manual, all args provided")
        manual.add_argument("-k", dest="kernel", help="kernel binary", required=True)
        manual.add_argument("-i", dest="initrd", help="initrd list", nargs="+", metavar="IMG", required=True)
        manual.add_argument("-c", dest="cmdline", help="kernel cmdline", required=True)
        manual.add_argument("-o", dest="output", help="signed kernel output", required=True)
        manual.add_argument("-K", dest="key", help="signing key")
        manual.add_argument("-C", dest="cert", help="signing certificate")
        manual.add_argument("-e", dest="stub", help="systemd-boot efistub")
        manual.add_argument("--logging", help="set logging level", choices=["INFO", "DEBUG", "WARN"])
        manual.set_defaults(**defaults, func=self.manual, name="manual")

        args = parser.parse_args()
        loglevel = getattr(logging, args.logging or "INFO")
        logging.basicConfig(
            format="[%(name)s] %(message)s", level=loglevel
        )
        args.func(args)

    # automatic mode
    def auto(self, args):

        # open configuration, add globbing
        conf = Configuration(args.config)
        if not args.no_glob: conf.find_kernels()

        # combine and sign kernels
        self.signall(conf.kernels())

    # hook mode for pacman
    def hook(self, args):

        # open configuration
        conf = Configuration(args.config)

        # parse targets on stdin
        targets, force = [], False
        for line in (line.strip() for _, line in enumerate(sys.stdin)):
            match = conf.rexp.match(line)
            if match is None:
                force = True
                continue
            # add matches to list of targets
            name = match.group(1)
            conf.add_section(name)
            targets.append(name)

        # if any target did not match kernel regexp, force auto rebuild
        if force:
            logger("*").info("forced complete resign")
            if not args.no_glob: conf.find_kernels()
            targets = None

        # combine and sign kernels
        self.signall(conf.kernels(targets))

    # fully manual mode
    def manual(self, args):

        kernel = Kernel(**(args.__dict__))
        self.signall([kernel])

    # helper to perform combine and sign
    def signall(self, kernels, backup=".bak"):
        for k in kernels:
            k.print().backup(backup).sign()


# ------- let's go -------
if __name__ == "__main__":
    Commandline()

